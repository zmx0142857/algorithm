quick_sort_partition(L, beg, end)
	pivot = L[end-1]
	i = beg
	j = end-2
	while i <= j:
		while i != end-1 and L[i] < pivot:
			++i
		while j != beg-1 and L[j] >= pivot:
			--j
		# i == end-1 or L[i] >= pivot
		# j == beg-1 or L[j] < pivot
		# we can prove that i != j
		if i < j:
			swap(L, i, j)
			++i, --j
		else:
			break
		# at the end of each iteration:
		# L[0...i-1] < pivot <= L[j+1..end-1]
	# i == j+1
	# L[j] < pivot <= L[i]
	swap(L, i, end-1)

# sort L[beg...end-1]
do_quick_sort(L, beg, end):
	if beg+1 >= end:
		return
	i = random_int(beg, end)
	swap(L, i, end-1)
	quick_sort_partition(L, beg, end)
	do_quick_sort(L, 0, i)
	do_quick_sort(L, i+1, end)

quick_sort(L):
	do_quick_sort(L, 0, L.length)

insert_sort(L):
	for i = 1...L.length-1:
		pivot = L[i]
		j = i-1
		while j != -1 and L[j] > pivot:
			L[j+1] = L[j]
			--j
		L[j+1] = pivot
		# L[0...i] is sorted
